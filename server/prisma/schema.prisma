generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// ENUMS
// ============================================

enum Role {
  USER
  MANAGER
  SUPER_ADMIN
}

enum UserStatus {
  ACTIVE
  BLOCKED
}

enum LedgerType {
  CREDIT
  DEBIT
}

enum RewardType {
  REFEREE_SIGNUP
  REFERRER_ORDER
}

enum RewardStatus {
  PENDING
  PROCESSED
  FAILED
}

enum PaymentStatus {
  INITIATED       // Order created, awaiting payment
  AUTHORIZED      // Payment verified, partner booking pending
  PAID            // Zero-amount: fully covered by wallet/promo
  CONFIRMED       // Partner booking success & payment success
  PARTNER_FAILED  // Payment OK, partner API failed
  FAILED          // Payment failed or signature invalid
  CANCELLED       // User cancelled or system rollback
  EXPIRED         // Abandoned: no payment within TTL
  REFUNDED        // Max partner retries exhausted, money returned
}

// ============================================
// USER MODEL (Updated)
// ============================================

model User {
  id            String     @id @default(uuid())
  name          String?
  email         String?    @unique
  mobile        String     @unique
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  isVerified    Boolean    @default(false)
  gender        String?
  age           Int?
  password      String?
  
  // New fields for Admin & Referral
  role          Role       @default(USER)
  status        UserStatus @default(ACTIVE)
  referralCode  String?    @unique
  referredById  String?
  
  // Relations
  addresses     Address[]
  bookings      Booking[]
  patients      Patient[]
  cart          Cart?
  wallet        Wallet?
  referredBy    User?      @relation("Referrals", fields: [referredById], references: [id])
  referrals     User[]     @relation("Referrals")
  referralRewardsEarned ReferralReward[] @relation("ReferrerRewards")
  auditLogs     AdminAuditLog[]
  promoRedemptions PromoRedemption[]
}

model OTP {
  id         String   @id @default(uuid())
  identifier String   @unique
  code       String
  expiresAt  DateTime
  attempts   Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Patient {
  id           String        @id @default(uuid())
  userId       String
  name         String
  relation     String
  age          Int
  gender       String
  bookingItems BookingItem[]
  cartItems    CartItem[]
  user         User          @relation(fields: [userId], references: [id])
}

model Address {
  id       String    @id @default(uuid())
  userId   String
  line1    String
  city     String
  pincode  String
  lat      String?
  long     String?
  user     User      @relation(fields: [userId], references: [id])
  bookings Booking[]
}

model Booking {
  id                String        @id @default(uuid())
  userId            String
  partnerBookingId  String?
  status            String
  slotDate          String
  slotTime          String
  totalAmount       Float
  paymentStatus     PaymentStatus @default(INITIATED)
  razorpayOrderId   String?       @unique
  razorpayPaymentId String?       @unique
  paidAt            DateTime?
  partnerError      String?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  addressId         String?
  billingName       String?           // Optional billing name for invoice
  billingGender     String?           // Gender of billing person (for Healthians)
  idempotencyKey    String?       @unique  // Prevent double-initiate
  address           Address?      @relation(fields: [addressId], references: [id])
  user              User          @relation(fields: [userId], references: [id])
  items             BookingItem[]
  reports           Report[]
  rescheduledToId   String?       @unique
  partnerRetry      PartnerRetry?

  // Price Breakdown
  discountAmount    Float         @default(0)
  walletAmount      Float         @default(0)
  finalAmount       Float         @default(0)
  
  promoCodeId       String?
  promoCode         PromoCode?    @relation(fields: [promoCodeId], references: [id])
  redemption        PromoRedemption?

  @@index([paymentStatus, updatedAt])     // Reconciler queries
  @@index([userId, paymentStatus])        // Active booking check
}

model BookingItem {
  id        String  @id @default(uuid())
  bookingId String
  patientId String
  testCode  String
  testName  String
  price     Float
  status    String?
  booking   Booking @relation(fields: [bookingId], references: [id])
  patient   Patient @relation(fields: [patientId], references: [id])
}

model Report {
  id          String   @id @default(uuid())
  bookingId   String
  reportUrl   String
  generatedAt DateTime @default(now())
  booking     Booking  @relation(fields: [bookingId], references: [id])
}

model CallbackRequest {
  id        String   @id @default(uuid())
  name      String
  mobile    String
  city      String
  status    String   @default("PENDING")
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Cart {
  id        String     @id @default(uuid())
  userId    String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items     CartItem[]
}

model CartItem {
  id        String   @id @default(uuid())
  cartId    String
  testCode  String
  testName  String
  price     Float
  mrp       Float?
  patientId String?
  createdAt DateTime @default(now())
  cart      Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)
  patient   Patient? @relation(fields: [patientId], references: [id])
}

// ============================================
// WALLET SYSTEM
// ============================================

model Wallet {
  id        String         @id @default(uuid())
  userId    String         @unique
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  user      User           @relation(fields: [userId], references: [id])
  ledger    WalletLedger[]
  balance   Float          @default(0) // Cached balance for atomic updates
}

model WalletLedger {
  id            String     @id @default(uuid())
  walletId      String
  type          LedgerType
  amount        Float      // Actual signed amount (+/-)
  balanceAfter  Float      // Running balance after this transaction
  description   String
  referenceType String?    // REFERRAL | TOPUP | REFUND | ORDER | ADMIN
  referenceId   String?    // ID of related entity
  createdAt     DateTime   @default(now())
  createdById   String?    // Admin userId for adjustments
  ipAddress     String?
  
  wallet        Wallet     @relation(fields: [walletId], references: [id])
  
  @@index([walletId, createdAt])
  @@unique([referenceType, referenceId]) // Prevent double-refund at DB level
}

// ============================================
// REFERRAL SYSTEM
// ============================================

model ReferralReward {
  id              String       @id @default(uuid())
  referrerId      String
  refereeId       String
  rewardType      RewardType
  amount          Float
  status          RewardStatus @default(PENDING)
  triggerEvent    String       // SIGNUP | FIRST_ORDER_COMPLETE
  triggerEntityId String?      // bookingId for order completion
  processedAt     DateTime?
  createdAt       DateTime     @default(now())
  
  referrer        User         @relation("ReferrerRewards", fields: [referrerId], references: [id])
  
  @@unique([referrerId, refereeId, rewardType])
  @@index([refereeId, rewardType])
}

// ============================================
// SYSTEM CONFIGURATION
// ============================================

model SystemConfig {
  id        String   @id @default(uuid())
  key       String   @unique
  value     String
  updatedAt DateTime @updatedAt
  updatedBy String?  // Admin userId who last updated
}

// ============================================
// ADMIN AUDIT LOG
// ============================================

model AdminAuditLog {
  id            String   @id @default(uuid())
  adminId       String
  adminName     String
  action        String   // WALLET_CREDIT | WALLET_DEBIT | CONFIG_UPDATE | USER_BLOCK etc.
  entity        String   // User | Wallet | Config | Order
  targetId      String?
  oldValue      Json?
  newValue      Json?
  ipAddress     String?
  isDestructive Boolean  @default(false)
  createdAt     DateTime @default(now())
  
  admin         User     @relation(fields: [adminId], references: [id])
  
  @@index([adminId, createdAt])
  @@index([entity, targetId])
}

// ============================================
// PAYMENT WEBHOOK DEDUPLICATION
// ============================================

model WebhookEvent {
  eventId   String   @id  // Razorpay event ID - unique by design
  processed Boolean  @default(true)
  createdAt DateTime @default(now())
  
  @@index([createdAt])
}

// ============================================
// PROMO CODE SYSTEM
// ============================================

model PromoCode {
  id              String   @id @default(uuid())
  code            String   @unique // Case-insensitive storage (uppercase)
  description     String?
  discountType    DiscountType
  discountValue   Float
  maxDiscount     Float?   // Cap for percentage discount
  minOrderValue   Float    @default(0)
  
  maxRedemptions  Int?     // Global limit (null = unlimited)
  maxPerUser      Int      @default(1) // Per-user limit (how many times each user can redeem)
  redeemedCount   Int      @default(0) // Atomic counter
  
  startsAt        DateTime @default(now())
  expiresAt       DateTime?
  isActive        Boolean  @default(true)
  
  redemptions     PromoRedemption[]
  bookings        Booking[]
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model PromoRedemption {
  id          String    @id @default(uuid())
  userId      String
  promoCodeId String
  bookingId   String?   @unique // Optional if redemption happens before booking creation, but usually locked to booking
  redeemedAt  DateTime  @default(now())
  
  user        User      @relation(fields: [userId], references: [id])
  promoCode   PromoCode @relation(fields: [promoCodeId], references: [id])
  booking     Booking?  @relation(fields: [bookingId], references: [id])
  
  @@index([userId, promoCodeId])
}

enum DiscountType {
  PERCENTAGE
  FLAT
}

// ============================================
// PARTNER RETRY QUEUE (Dead-letter pattern)
// ============================================

model PartnerRetry {
  id          String   @id @default(uuid())
  bookingId   String   @unique
  attempts    Int      @default(0)
  maxAttempts Int      @default(3)
  lastError   String?
  nextRetryAt DateTime @default(now())
  createdAt   DateTime @default(now())
  booking     Booking  @relation(fields: [bookingId], references: [id])

  @@index([nextRetryAt, attempts])
}

// ============================================
// INTERNAL CATALOG (Manager-controlled)
// ============================================

enum CatalogItemType {
  TEST
  PACKAGE
  PROFILE
}

model CatalogItem {
  id               String             @id @default(uuid())
  partnerCode      String             @unique   // Healthians deal_id â€” canonical key
  name             String
  type             CatalogItemType    @default(TEST)
  
  // Pricing: manager-set
  partnerPrice     Float              // Healthians base price (reference only)
  displayPrice     Float              // Manager price shown to users
  discountedPrice  Float?             // Optional sale price
  
  // Metadata
  description      String?
  parameters       String?            // e.g. "Includes 60+ parameters"
  sampleType       String?            // e.g. "Blood"
  reportTime       String?            // e.g. "24-48 hours"
  partnerData      Json?              // Raw Healthians response for reference
  
  isEnabled        Boolean            @default(true)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  
  categories       CatalogItemCategory[]
  
  @@index([isEnabled])
  @@index([type, isEnabled])
}

model Category {
  id          String              @id @default(uuid())
  name        String              @unique
  slug        String              @unique
  description String?
  sortOrder   Int                 @default(0)
  isActive    Boolean             @default(true)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  
  items       CatalogItemCategory[]
  
  @@index([isActive, sortOrder])
}

model CatalogItemCategory {
  id            String      @id @default(uuid())
  catalogItemId String
  categoryId    String
  sortOrder     Int         @default(0)
  
  catalogItem   CatalogItem @relation(fields: [catalogItemId], references: [id], onDelete: Cascade)
  category      Category    @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  @@unique([catalogItemId, categoryId])
  @@index([categoryId, sortOrder])
}
